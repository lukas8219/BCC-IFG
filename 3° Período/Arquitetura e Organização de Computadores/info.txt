a memória deve ser um vetor de palavras de oito bits de 154 posições, unsigned char memoria[154]

todas as transferências entre MBR e a memória devem ser de byte em byte

O simulador deve possuir uma maneira de ler um arquivo texto para carregar a memória com instruções e dados como
apresentado na última página -> a entrada é um arquivo de texto

registradores:
- MBR – Memory Buffer Register
- MAR – Memory Address Register
- IR – Instruction Register
- RO0 – Register Operand 0
- RO1 – Register Operand 1
- IMM – Immediate
- PC – Program Counter unsigned short int pc
- E, L e G – registradores internos que armazenam as flags ‘equal to’, ‘lower than’ e ‘greater than’
- r0 a r3 – registradores de propósito-geral (GPRs) utilizados para manter temporariamente os operandos na ALU. unsigned short int reg[4]

dados sempre ocupam 2 bytes
instruções podem ocupar de 1 a 3
    hlt/nop: 1 byte
        0-4, opcode, 5-7, null
    load/store/operacoes matematicas/operacoes logicas: 3 bytes



BUSCA
se read:
    PC inorma MBA o endereço em RAM da próxima instrução
    MBA solicita a RAM a próxima instrução
    MBR recebe uma cópia da instrução
se write:
    PC informa a MBA o local onde a instrução deve ser armazenada
    AC envia uma cópia do resultado da operação para MBR
    MBR armazena o resultado no local indicado por MBA

decodifica


executa


==============================[ CPU ]==============================
| R0:   0 | R1:   0 | R2:   0 | R3:   0 |
| MBR:  0 | MAR:  0 | IMM:  0 | PC:   0 |
| IR:   0 | RO0:  0 | RO1:  0 |
| E:    0 | L:    0 | G:    0 |
==================================================================

============================[ Memory ]============================
|  0:   0 |  1:   0 |  2:   0 |  3:   0 |  4:   0 |  5:   0 |  6:   0 |  7:   0 | 
8:   0 |  9:   0 | 10:   0 | 11:   0 | 12:   0 | 13:   0 | 15:   0 |
| 16:   0 | 17:   0 | 18:   0 | 19:   0 | 20:   0 | 21:   0 | 22:   0 | 23:   0 |
| 24:   0 | 25:   0 | 26:   0 | 27:   0 | 28:   0 | 29:   0 | 30:   0 | 31:   0 |
| 32:   0 | 33:   0 | 34:   0 | 35:   0 | 36:   0 | 37:   0 | 38:   0 | 39:   0 |
| 40:   0 | 41:   0 | 42:   0 | 43:   0 | 44:   0 | 45:   0 | 46:   0 | 47:   0 |
| 48:   0 | 49:   0 | 50:   0 | 51:   0 | 52:   0 | 53:   0 | 54:   0 | 55:   0 |
| 56:   0 | 57:   0 | 58:   0 | 59:   0 | 60:   0 | 61:   0 | 62:   0 | 63:   0 |
| 64:   0 | 65:   0 | 66:   0 | 67:   0 | 68:   0 | 69:   0 | 70:   0 | 71:   0 |
| 72:   0 | 73:   0 | 74:   0 | 75:   0 | 76:   0 | 77:   0 | 78:   0 | 79:   0 |
| 80:   0 | 81:   0 | 82:   0 | 83:   0 | 84:   0 | 85:   0 | 86:   0 | 87:   0 |
| 88:   0 | 89:   0 | 90:   0 | 91:   0 | 92:   0 | 93:   0 | 94:   0 | 95:   0 |
| 96:   0 | 97:   0 | 98:   0 | 99:   0 |100:   0 |101:   0 |102:   0 |103:   0 |
|104:   0 |105:   0 |106:   0 |107:   0 |108:   0 |109:   0 |110:   0 |111:   0 |
|112:   0 |113:   0 |114:   0 |115:   0 |116:   0 |117:   0 |118:   0 |119:   0 |
|120:   0 |121:   0 |122:   0 |123:   0 |124:   0 |125:   0 |126:   0 |127:   0 |
|128:   0 |129:   0 |130:   0 |131:   0 |132:   0 |133:   0 |134:   0 |135:   0 |
|136:   0 |137:   0 |138:   0 |139:   0 |140:   0 |141:   0 |142:   0 |143:   0 |
|144:   0 |145:   0 |146:   0 |147:   0 |148:   0 |149:   0 |150:   0 |151:   0 |
|152:   0 |153:   0 |
==================================================================

[Pressione uma tecla para iniciar o próximo ciclo da máquina ou aperte CTRL + C para encerrar.]


1. Busca:
Instruções podem ter até três tamanhos: 1, 2 ou 3 bytes, é preciso verificar
o opcode antes de copiar da memória para descobrir onde a palavra se encerra.
    - 1 byte: hlt(0), nop(1) e not(11)
    - 2 bytes: